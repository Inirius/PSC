#pragma kernel CSMain

Texture2D<float4> Source;
RWTexture2D<float4> Destination;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _Light;
bool positionLight;

static const float maxDst = 800;
static const float epsilon = 0.001f;
static const float shadowBias = epsilon * 50;

struct Shape {
    
    float3 position;
    float3 size;
    float3 colour;
    int shapeType;
    int operation;
    float blendStrength;
    int numChildren;
    float3 rotation;
    float T_temporel;
};

StructuredBuffer<Shape> shapes;
int numShapes;



float sin_p(float x) {
    //return (x-pow(x,3)/6+pow(x,5)/120-pow(x,7)/5040+pow(x,9)/362880);//-pow(x,11)/39916800+pow(x,13)/6227020800-pow(x,15)/1307674368000+pow(x,17)/355687428096000-pow(x,19)/121645100408832000);
    return sin(x);
}

float cos_p(float x) {
    //return (1-pow(x,2)/4+pow(x,4)/24-pow(x,6)/720+pow(x,8)/40320-pow(x,10)/3628800);//+pow(x,12)/479001600-pow(x,14)/87178291200+pow(x,16)/20922789888000-pow(x,18)/6402373705728000+pow(x,20)/2432902008176640000);
    return cos(x);
}

float sinh(float x) {
    return (exp(x)-exp(-x))/2;
}

struct Ray {
    float3 origin;
    float3 direction;
};

struct Combined {
    float dst;
    float3 colour;
    float T_temporel;
    int object;
};

Combined CreateCombined(float dst, float3 colour, float T_temporel, int object) {
    Combined combined;
    combined.dst = dst;
    combined.colour = colour;
    combined.T_temporel = T_temporel;
    combined.object = object;
    return combined;
}

float3 Tourne(float3 rot,float3 coor) {
    return float3(coor.x*(cos_p(rot.y)*cos_p(rot.z)-sin_p(rot.y)*cos_p(rot.x)*sin_p(rot.z))-coor.y*(cos_p(rot.y)*sin_p(rot.z)+sin_p(rot.y)*cos_p(rot.z)*cos_p(rot.x))+coor.z*sin_p(rot.y)*sin_p(rot.x),
    coor.x*(sin_p(rot.y)*cos_p(rot.z)+cos_p(rot.y)*cos_p(rot.x)*sin_p(rot.z))+coor.y*(-sin_p(rot.y)*sin_p(rot.z)+cos_p(rot.y)*cos_p(rot.z)*cos_p(rot.x))-coor.z*cos_p(rot.y)*sin_p(rot.x),
    coor.x*sin_p(rot.x)*sin_p(rot.z)+coor.y*sin_p(rot.x)*cos_p(rot.z)+coor.z*cos_p(rot.x));
}

float3 TourneInv(float3 rot,float3 coor) {
    return float3(coor.x*(cos_p(rot.z)*cos_p(rot.y)-sin_p(rot.z)*cos_p(rot.x)*sin_p(rot.y))+coor.y*(cos_p(rot.z)*sin_p(rot.y)+sin_p(rot.z)*cos_p(rot.y)*cos_p(rot.x))+coor.z*sin_p(rot.z)*sin_p(rot.x),
    -coor.x*(sin_p(rot.z)*cos_p(rot.y)+cos_p(rot.z)*cos_p(rot.x)*sin_p(rot.y))+coor.y*(-sin_p(rot.z)*sin_p(rot.y)+cos_p(rot.z)*cos_p(rot.y)*cos_p(rot.x))+coor.z*cos_p(rot.z)*sin_p(rot.x),
    coor.x*sin_p(rot.x)*sin_p(rot.y)-coor.y*sin_p(rot.x)*cos_p(rot.y)+coor.z*cos_p(rot.x));
}

float SphereDistance(float3 eye, float3 centre, float radius) {
    return distance(eye, centre) - radius;
}

 ///........................
float CubeDistance(float3 eye, float3 centre, float3 size, float3 rot) {
    float3 o = abs(Tourne(rot,eye-centre)) -size;
    float ud = length(max(o,0));
    float n = max(max(min(o.x,0),min(o.y,0)), min(o.z,0));
    return ud+n;
}

// Following distance functions from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
float TorusDistance(float3 eye, float3 centre, float r1, float r2, float3 rot)
{   float3 coor = Tourne(rot,eye-centre);
    float2 q = float2(length(coor.xz)-r1,coor.y);
    return length(q)-r2;
}

float PrismDistance(float3 eye, float3 centre, float3 h, float3 rot) {
    float3 neye = Tourne(rot,eye-centre);
    float3 q = abs(Tourne(rot,eye-centre));
    return max(q.z-h.y,max(q.x*cos_p(h.z)+ neye.y*sin_p(h.z),- neye.y)-h.x*sin_p(h.z));
}


float CylinderDistance(float3 eye, float3 centre, float2 h, float3 rot) {
    float3 neye = Tourne(rot,eye-centre);
    float2 d = abs(float2(length((neye).xz), neye.y)) - h;
    return length(max(d,0.0)) + max(min(d.x,0),min(d.y,0));
}

float ConeDistance(float3 eye, float3 centre, float3 h, float3 rot)
{
    float2 q = h.z * float2(h.x / h.y, -1.0);
    float3 p = Tourne(rot,eye-centre);
    float2 w = float2(sqrt(p.x * p.x + p.z * p.z), p.y);
    float2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
    float2 b = w - q * float2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
    float k = sign(q.y);
    float d = min(dot(a, a), dot(b, b));
    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
    return sqrt(d) * sign(s);
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}

// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
Combined Blend( float a, float b, float3 colA, float3 colB, float k, float T_temporelA, float T_temporelB)
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    float blendDst = lerp( b, a, h ) - k*h*(1.0-h);
    float3 blendCol = lerp(colB,colA,h);
    float blendT_temporel = lerp(T_temporelB,T_temporelA,h);
    int blendObject = (h > 0.5)?1:0;
    return CreateCombined(blendDst,blendCol,blendT_temporel,blendObject);
}

Combined Combine(float dstA, float dstB, float3 colourA, float3 colourB, int operation, float blendStrength, float T_temporelA, float T_temporelB, int a, int b) {
    float dst = dstA;
    float3 colour = colourA;
    float T_temporel = T_temporelA;
    int k = a;

    if (operation == 0) {
        if (dstB < dstA) {
            dst = dstB;
            colour = colourB;
            T_temporel = T_temporelB;
            k = b;
        }
    } 
    // Blend
    else if (operation == 1) {
        Combined blend = Blend(dstA,dstB,colourA,colourB, blendStrength, T_temporelA, T_temporelB);
        dst = blend.dst;
        colour = blend.colour;
        T_temporel = blend.T_temporel;
        k = (blend.object==1)?b:a;

    }
    // Cut
    else if (operation == 2) {
        // max(a,-b)
        if (-dstB > dst) {
            dst = -dstB;
            colour = colourB;
            T_temporel = T_temporelB;
            k = b;
        }
    }
    // Mask
    else if (operation == 3) {
        // max(a,b)
        if (dstB > dst) {
            dst = dstB;
            colour = colourB;
            T_temporel = T_temporelB;
            k = b;
        }
    }
    // Hide : nothing
    // Show : Mask, but only visually
    else if (operation == 5) {
        // max(a,b)
        if (dstB > dst) {
            dst = dstB;
            }
    }

    return CreateCombined(dst,colour,T_temporel,k);
}

float GetShapeDistance(Shape shape, float3 eye) {
   
    if (shape.shapeType == 0) {
        return SphereDistance(eye, shape.position, shape.size.x);
    }
    else if (shape.shapeType == 1) {
        return CubeDistance(eye, shape.position, shape.size, shape.rotation);
    }
    else if (shape.shapeType == 2) {
        return TorusDistance(eye, shape.position, shape.size.x, shape.size.y, shape.rotation);
    }
    else if (shape.shapeType == 3) {
        return PrismDistance(eye, shape.position, shape.size, shape.rotation);
    }
    else if (shape.shapeType == 4) {
        return CylinderDistance(eye, shape.position, shape.size.xy, shape.rotation);
    }
    else if (shape.shapeType == 5) {
        return ConeDistance(eye, shape.position, shape.size, shape.rotation);
    }

    return maxDst;
}

float GetShapeDistance(Shape shape, float3 eye, float3 parent, float3 rot) {
   
    if (shape.shapeType == 0) {
        return SphereDistance(parent + Tourne(rot,eye - parent), shape.position, shape.size.x);
    }
    else if (shape.shapeType == 1) {
        return CubeDistance(parent + Tourne(rot,eye-parent), shape.position, shape.size, shape.rotation);
    }
    else if (shape.shapeType == 2) {
        return TorusDistance(parent + Tourne(rot,eye-parent) , shape.position, shape.size.x, shape.size.y, shape.rotation);
    }
    else if (shape.shapeType == 3) {
        return PrismDistance(parent + Tourne(rot,eye - parent), shape.position, shape.size, shape.rotation);
    }
    else if (shape.shapeType == 4) {
        return CylinderDistance(parent + Tourne(rot,eye - parent), shape.position, shape.size.xy, shape.rotation);
    }
    else if (shape.shapeType == 5) {
        return ConeDistance(parent + Tourne(rot,eye - parent), shape.position, shape.size, shape.rotation);
    }

    return maxDst;
}

float GetObjectDistance(int i, float3 eye, bool util) {
    // eye : position du point
    // i : index de l'objet
    // util : considérer les objets cachés

        Shape shape = shapes[i];
        int numChildren = shape.numChildren;

        float localDst = GetShapeDistance(shape,eye);

        for (int j = 0; j < numChildren; j ++) {
            Shape childShape = shapes[i+j+1];
            float childDst = GetShapeDistance(childShape,eye,shape.position,shape.rotation);
            int ope = childShape.operation;
           if (ope == 4)  ope = (1-util) * ope;
           if (ope == 5) ope = 4 * util + (1-util) * 3;
        // modifier le combine pour qu'il renvoie l'indice du fils le plus proche
            Combined combined = Combine(localDst, childDst, shape.colour, childShape.colour, ope, childShape.blendStrength,0,0,0,0);
            localDst = combined.dst;
        }
        
    return localDst;
}


Combined SceneInfo(float3 eye) {
    float globalDst = maxDst;
    float3 globalColour = 1;
    float globalT_temporel = 0;
    int globalIndex = -1;
    
    for (int i = 0; i < numShapes; i ++) {
        Shape shape = shapes[i];
        int numChildren = shape.numChildren;

        float localDst = GetShapeDistance(shape,eye);
        float3 localColour = shape.colour;
        float localT_temporel = shape.T_temporel;
        int localIndex = i;


        for (int j = 0; j < numChildren; j ++) {
            Shape childShape = shapes[i+j+1];
            float childDst = GetShapeDistance(childShape,eye,shape.position,shape.rotation);

            Combined combined = Combine(localDst, childDst, localColour, childShape.colour, childShape.operation, childShape.blendStrength,localT_temporel,childShape.T_temporel,i,i+j+1);
            localColour = combined.colour;
            localDst = combined.dst;
            localT_temporel = combined.T_temporel;
            localIndex = combined.object;
        }
        i+=numChildren; // skip over children in outer loop
        
        Combined globalCombined = Combine(globalDst, localDst, globalColour, localColour, shape.operation, shape.blendStrength,globalT_temporel,localT_temporel,globalIndex,localIndex);
        globalColour = globalCombined.colour;
        globalDst = globalCombined.dst;
        globalT_temporel = globalCombined.T_temporel;
        globalIndex = globalCombined.object;        
    }

    return CreateCombined(globalDst,globalColour,globalT_temporel,globalIndex);
}

float3 EstimateNormal(float3 p) {
    float x = SceneInfo(float3(p.x+epsilon,p.y,p.z)).dst - SceneInfo(float3(p.x-epsilon,p.y,p.z)).dst;
    float y = SceneInfo(float3(p.x,p.y+epsilon,p.z)).dst - SceneInfo(float3(p.x,p.y-epsilon,p.z)).dst;
    float z = SceneInfo(float3(p.x,p.y,p.z+epsilon)).dst - SceneInfo(float3(p.x,p.y,p.z-epsilon)).dst;
    return normalize(float3(x,y,z));
}

float CalculateShadow(Ray ray, float dstToShadePoint) {
    float rayDst = 0;
    int marchSteps = 0;
    float shadowIntensity = .2;
    float brightness = 1;

    while (rayDst < dstToShadePoint) {
        marchSteps ++;
        Combined sceneInfo = SceneInfo(ray.origin);
        float dst = sceneInfo.dst;
        
        if (dst <= epsilon) {
            return shadowIntensity;
        }

        brightness = min(brightness,dst*200);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
    return shadowIntensity + (1-shadowIntensity) * brightness;
}

float _Radius = 10000;
float _Hot = 10;
float _Cold = 0;
float _Accuracy = 3;
float pi = 3.1415926;

float distance_chaud(float3 position, int chaud) {
    // Renvoit la distance à la surface chaude
    
   // return SphereDistance(position, float3(10,0,0), 1);

   return GetObjectDistance(chaud,position,true);
}

float random(float2 x)
{
    return frac(sin_p(dot(x,float2(12.9898,78.233)))*43758.5453123);
}

float solvewos(float3 p0, int walkSamples) {
    // Resouds l'equation de Poisson pour un point p0, avec walkSamples marches 
    
    float epsilon = 0.005;
    float sum = 0;
    float pi = 3.1415926; 
    int chaud = shapes[0].numChildren+1; 

    for (int walk = 0; walk < walkSamples; walk++) {
        float3 p = p0;
        
        int iterations = 0;
        
        float couche_air = 0.1;

        while (distance_chaud(p,chaud) > epsilon && iterations < 100 && GetObjectDistance(0,p,true) < couche_air  ) {
            float internalRadius = abs(GetObjectDistance(0,p,true)-couche_air);
            float theta = 2 * pi * random((walk*walk+1)*float2(p.x*p.x+1,p.z*p.z+1));
            float phi = pi * random((walk*walk+1)*100000*float2(p.y*p.y+1,p.x*p.x+1));
            p = float3(p.x + internalRadius * sin_p(theta) * cos_p(phi), p.y + internalRadius * sin_p(theta) * sin_p(phi), p.z + internalRadius * cos_p(theta));            
            iterations++;
        }

        if (distance_chaud(p,chaud) <= epsilon) {         
            sum += 1;
        }       
        
    }
    return sum/walkSamples;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];

    float2 uv = id.xy / float2(width,height) * 2 - 1;
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < maxDst) {
        marchSteps ++;
        Combined sceneInfo = SceneInfo(ray.origin);
        float dst = sceneInfo.dst;
        
        if (dst <= epsilon) {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = EstimateNormal(pointOnSurface - ray.direction * epsilon);
            float3 lightDir = (positionLight)?normalize(_Light-ray.origin):-_Light;
            float lighting = saturate(saturate(dot(normal,lightDir)));
            float3 col = sceneInfo.colour;
            float T_temp = sceneInfo.T_temporel; // MEF C'est alpha*t pas simlpement t
            int index = sceneInfo.object;
            float x_dim = maxDst;
            float y_dim = maxDst;
            float z_dim = maxDst;
            if (index >= 0) {
                float x_dim = shapes[index].size.x;
                float y_dim = shapes[index].size.y;
                float z_dim = shapes[index].size.z;
            }
                        
            int i_MAX = 0;
            int samples = 3;
            float pi = 3.1415926;

            // Shadow
            float3 offsetPos = pointOnSurface + normal * shadowBias;
            float3 dirToLight = (positionLight)?normalize(_Light- offsetPos):-_Light;

            ray.origin = offsetPos;
            ray.direction = dirToLight;

            float dstToLight = (positionLight)?distance(offsetPos,_Light):maxDst;
            float shadow = CalculateShadow(ray, dstToLight);

            float tempe = 0;
            
            if (GetObjectDistance(0,pointOnSurface,false)<0.01) {
                tempe = solvewos(pointOnSurface,10);
            }
            
            Destination[id.xy] = float4(col * lighting * shadow,1) + (tempe) * (1-exp(- T_temp * pi * pi / 4 * ( 1/(x_dim*x_dim) + 1/(y_dim*y_dim) + 1/(z_dim*z_dim)))) * float4(10,0,0,0);

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
}
